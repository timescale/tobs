package timescaledb_secrets

import (
	"bytes"
	"crypto/ecdsa"
	"crypto/elliptic"
	"crypto/rand"
	"crypto/x509"
	"crypto/x509/pkix"
	"encoding/pem"
	"fmt"
	"math/big"
	"os"
	"time"

	"github.com/timescale/tobs/cli/pkg/k8s"
	"github.com/timescale/tobs/cli/pkg/utils"
	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

type TSDBSecretsInfo struct {
	ReleaseName    string
	Namespace      string
	EnableS3Backup bool
	TlsCert        []byte
	TlsKey         []byte
	K8sClient      k8s.Client
}

func (t *TSDBSecretsInfo) CreateTimescaleDBSecrets() error {
	// Previous helm install used to create namespace if it doesn't exist
	// but as we are creating secrets prior to deploying tobs. We are verifying
	// namespace if doesn't create one.
	err := t.K8sClient.CreateNamespaceIfNotExists(t.Namespace)
	if err != nil {
		return err
	}

	if t.TlsCert == nil && t.TlsKey == nil {
		err = t.createTimescaleDBCertificates()
		if err != nil {
			return err
		}
	} else {
		fmt.Println("Using the provided TLS certificates for TimescaleDB.")
	}

	err = t.createTimescaleDBCredentials()
	if err != nil {
		return err
	}

	if t.EnableS3Backup {
		err = t.createS3BackupForTimescaleDB()
		if err != nil {
			return err
		}
	} else {
		fmt.Println("skipping to create TimescaleDB s3 backup secret as backup option is disabled.")
	}

	return nil
}

// randomPassword generates a random alphanumeric password of a given length.
// Compatible with passwords generated by the postgres operator
func randomPassword(n int) ([]byte, error) {
	var passwordChars = []byte("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789")
	b := make([]byte, n)
	_, err := rand.Read(b)
	if err != nil {
		return b, fmt.Errorf("failed to generate random password %v", err)
	}
	for i := 0; i < n; i++ {
		b[i] = passwordChars[b[i]%uint8(len(passwordChars))]
	}
	return b, nil
}

func (t *TSDBSecretsInfo) createTimescaleDBCredentials() error {
	secretName := t.ReleaseName + "-credentials"
	exists, err := t.K8sClient.CheckSecretExists(secretName, t.Namespace)
	if err != nil {
		return err
	}

	if exists {
		fmt.Printf("using existing %s secret\n", secretName)
		return nil
	}

	fmt.Printf("Creating TimescaleDB %s secret\n", secretName)
	repPass, err := randomPassword(10)
	if err != nil {
		return err
	}
	adminPass, err := randomPassword(10)
	if err != nil {
		return err
	}
	superUserPass, err := randomPassword(10)
	if err != nil {
		return err
	}
	sec := &corev1.Secret{
		ObjectMeta: metav1.ObjectMeta{
			Name:      secretName,
			Namespace: t.Namespace,
			Labels:    utils.GetTimescaleDBsecretLabels(t.ReleaseName),
		},
		Data: map[string][]byte{
			"PATRONI_REPLICATION_PASSWORD": repPass,
			"PATRONI_admin_PASSWORD":       adminPass,
			"PATRONI_SUPERUSER_PASSWORD":   superUserPass,
		},
		Type: "Opaque",
	}

	return t.K8sClient.CreateSecret(sec)
}

func generateCerts() ([]byte, []byte, error) {
	priv, err := ecdsa.GenerateKey(elliptic.P256(), rand.Reader)
	if err != nil {
		return nil, nil, fmt.Errorf("failed to generate rsa key: %v", err)
	}

	serialNumberLimit := new(big.Int).Lsh(big.NewInt(1), 128)
	serialNumber, err := rand.Int(rand.Reader, serialNumberLimit)
	if err != nil {
		return nil, nil, fmt.Errorf("failed to generate serial number: %v", err)
	}

	template := x509.Certificate{
		SerialNumber: serialNumber,
		Subject: pkix.Name{
			CommonName:   "Tobs TimescaleDB Fake Certificate",
			Organization: []string{"Acme Co"},
		},
		NotBefore:             time.Now(),
		NotAfter:              time.Now().Add(time.Hour * 24 * 1000),
		KeyUsage:              x509.KeyUsageDigitalSignature,
		ExtKeyUsage:           []x509.ExtKeyUsage{x509.ExtKeyUsageServerAuth},
		BasicConstraintsValid: true,
	}

	derBytes, err := x509.CreateCertificate(rand.Reader, &template, &template, &priv.PublicKey, priv)
	if err != nil {
		return nil, nil, fmt.Errorf("failed to create certificate: %v", err)
	}

	certOut, err := pemEncodeCert(derBytes)
	if err != nil {
		return nil, nil, fmt.Errorf("failed to write data to cert.pem: %v", err)
	}

	keyOut, err := pemEncodePrivateKey(priv)
	if err != nil {
		return nil, nil, fmt.Errorf("failed to encode private key: %v", err)
	}

	return certOut, keyOut, nil
}

type s3Details struct {
	BucketName     string
	EndpointName   string
	EndpointRegion string
	Key            string
	Secret         string
}

func (t *TSDBSecretsInfo) createTimescaleDBCertificates() error {
	fmt.Print(`
WARNING: Using a generated self-signed certificate for TLS access to TimescaleDB.
         This should only be used for development and demonstration purposes.
         To use a signed certificate, use the "--tls-timescaledb-cert" and "--tls-timescaledb-key"
         flags when issuing the tobs install command.

`)
	secretName := t.ReleaseName + "-certificate"
	exists, err := t.K8sClient.CheckSecretExists(secretName, t.Namespace)
	if err != nil {
		return err
	}

	if exists {
		fmt.Printf("using existing %s secret\n", secretName)
		return nil
	}

	fmt.Printf("Creating TimescaleDB %s secret\n", secretName)
	publicKey, privateKey, err := generateCerts()
	if err != nil {
		return err
	}

	sec := &corev1.Secret{
		ObjectMeta: metav1.ObjectMeta{
			Name:      secretName,
			Namespace: t.Namespace,
			Labels:    utils.GetTimescaleDBsecretLabels(t.ReleaseName),
		},
		Data: map[string][]byte{"tls.key": privateKey, "tls.crt": publicKey},
		Type: "Opaque",
	}

	return t.K8sClient.CreateSecret(sec)
}

func (t *TSDBSecretsInfo) createS3BackupForTimescaleDB() error {
	s3 := s3Details{}
	//fmt.Print("We'll be asking a few questions about S3 buckets, keys, secrets and endpoints.\n\nFor background information, visit these pages:\n\nAmazon Web Services:\n- https://docs.aws.amazon.com/AmazonS3/latest/gsg/CreatingABucket.html\n- https://docs.aws.amazon.com/IAM/latest/UserGuide/introduction.html\n\nDigital Ocean:\n- https://developers.digitalocean.com/documentation/spaces/#aws-s3-compatibility\n\nGoogle Cloud:\n- https://cloud.google.com/storage/docs/migrating#migration-simple\n\n")
	fmt.Print(`
We'll be asking a few questions about S3 buckets, keys, secrets and endpoints.

For background information, visit these pages:

Amazon Web Services:
- https://docs.aws.amazon.com/AmazonS3/latest/gsg/CreatingABucket.html
- https://docs.aws.amazon.com/IAM/latest/UserGuide/introduction.html

Digital Ocean:
- https://developers.digitalocean.com/documentation/spaces/#aws-s3-compatibility

Google Cloud:
- https://cloud.google.com/storage/docs/migrating#migration-simple

`)
	// if values are available in env variables pick up them else
	// read from the user input.
	s3.BucketName = os.Getenv("PGBACKREST_REPO1_S3_BUCKET")
	if s3.BucketName == "" {
		fmt.Println("What is the name of the S3 bucket?")
		fmt.Scanln(&s3.BucketName)
	} else {
		fmt.Println("S3 bucket found in env, using env variable 'PGBACKREST_REPO1_S3_BUCKET'")
	}

	s3.EndpointName = os.Getenv("PGBACKREST_REPO1_S3_ENDPOINT")
	if s3.EndpointName == "" {
		fmt.Println("\nWhat is the name of the S3 endpoint? (leave blank for default)")
		fmt.Scanln(&s3.EndpointName)
	} else {
		fmt.Println("S3 endpoint found in env, using env variable 'PGBACKREST_REPO1_S3_ENDPOINT'")
	}

	s3.EndpointRegion = os.Getenv("PGBACKREST_REPO1_S3_REGION")
	if s3.EndpointRegion == "" {
		fmt.Println("\nWhat is the region of the S3 endpoint? (leave blank for default)")
		fmt.Scanln(&s3.EndpointRegion)
	} else {
		fmt.Println("S3 region found in env, using env variable 'PGBACKREST_REPO1_S3_REGION'")
	}

	s3.Key = os.Getenv("PGBACKREST_REPO1_S3_KEY")
	if s3.Key == "" {
		fmt.Println("\nWhat is the S3 Key to use?")
		fmt.Scanln(&s3.Key)
	} else {
		fmt.Println("S3 key found in env, using env variable 'PGBACKREST_REPO1_S3_KEY'")
	}

	s3.Secret = os.Getenv("PGBACKREST_REPO1_S3_KEY_SECRET")
	if s3.Secret == "" {
		fmt.Println("\nWhat is the S3 Secret to use?")
		fmt.Scanln(&s3.Secret)
	} else {
		fmt.Println("S3 secret found in env, using env variable 'PGBACKREST_REPO1_S3_KEY_SECRET'")
	}

	fmt.Println()
	err := t.createTimescaleDBPgBackRest(t.ReleaseName, t.Namespace, s3)
	if err != nil {
		return err
	}

	return nil
}

func (t *TSDBSecretsInfo) createTimescaleDBPgBackRest(name, namespace string, s3 s3Details) error {
	secretName := name + "-pgbackrest"
	exists, err := t.K8sClient.CheckSecretExists(secretName, namespace)
	if err != nil {
		return err
	}

	if exists {
		fmt.Printf("using existing %s secret\n", secretName)
		return nil
	}

	fmt.Printf("Creating TimescaleDB %s secret\n", secretName)
	data := map[string][]byte{
		"PGBACKREST_REPO1_S3_BUCKET":     []byte(s3.BucketName),
		"PGBACKREST_REPO1_S3_KEY":        []byte(s3.Key),
		"PGBACKREST_REPO1_S3_KEY_SECRET": []byte(s3.Secret),
	}

	if s3.EndpointName != "" {
		data["PGBACKREST_REPO1_S3_ENDPOINT"] = []byte(s3.EndpointName)
	}

	if s3.EndpointRegion != "" {
		data["PGBACKREST_REPO1_S3_REGION"] = []byte(s3.EndpointRegion)
	}

	sec := &corev1.Secret{
		ObjectMeta: metav1.ObjectMeta{
			Name:      secretName,
			Namespace: namespace,
			Labels:    utils.GetTimescaleDBsecretLabels(t.ReleaseName),
		},
		Data: data,
		Type: "Opaque",
	}

	return t.K8sClient.CreateSecret(sec)
}

func pemEncodeCert(certDerBytes []byte) ([]byte, error) {
	block := &pem.Block{
		Type:  "CERTIFICATE",
		Bytes: certDerBytes,
	}
	buffer := new(bytes.Buffer)
	if err := pem.Encode(buffer, block); err != nil {
		return nil, fmt.Errorf("failed to pem encode cert: %v", err)
	}
	return buffer.Bytes(), nil
}

func pemEncodePrivateKey(privateKey *ecdsa.PrivateKey) ([]byte, error) {
	kBytes, err := x509.MarshalECPrivateKey(privateKey)
	if err != nil {
		return nil, err
	}
	block := &pem.Block{
		Type:  "EC PRIVATE KEY",
		Bytes: kBytes,
	}
	buffer := new(bytes.Buffer)
	if err := pem.Encode(buffer, block); err != nil {
		return nil, err
	}
	return buffer.Bytes(), nil
}
